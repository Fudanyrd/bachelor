%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Keep each line less than 80 characters.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{引\quad 言}

%^C^C Overview of Large Language Models.
% \par Increased computational power, advanced machine-learning model
% \citep{attention}, and access to very large-scale data have led to a
% significant transition to the emergence of \textbf{Large Language Models}
% \citep{overviewllm, llmsurvey}. Trained with expansive and diverse data, pretrained 
% large language models have demonstrated remarkable capability to 
% understand and generate human-like text, making them suitable for 
% various Natural Language Processing (NLP) tasks\citep{nlp}.
% Further supervised finetuning (SFT) \citep{sft} equips such models with 
% ability to follow natural language instructions,
% making them powerful tools for a wide range 
% of applications. Large language models, such as ChatGPT \citep{chatgpt},
% LLama \citep{llama}, and Gemini \citep{gemini}, because of their
% rich domain-specific knowledge, have been employed be engineers and
% researchers to automate workflows across various domains.

%^C^C Jump to the point of automated debugging techniques as a whole.
% Repairing bugs can be a time-consuming and daunting task
% for even a expert experienced in debugging, so naturally,
% attempting to automatically repair programs is quite challenging.
% 
% Before the era of large language models, automated program repair (APR)
% is implemented by Genetic Programming \citep{genprog}, TODO(...).
% Patches generated by these methods unfortunately tend to 
% overfit and break program properties in subtle ways.

%^C^C What about automated debugging of memory errors? 
%^C^C existing works, challenges (why difficult), etc.
% \textit{C} and \textit{C++} are popular system programming languages 
% which do not check memory accesses during execution, causing
% memory bugs to slip in. Memory bugs, such as stack/heap overflow,
% use-after-free, and double free, are common causes of software vulnerabilities 
% and can lead to severe consequences. Moreover, memory bugs 
% are notoriously hard to localize; for a single memory error may not
% have immediately visible consequenses (e.g. process crash or abort).
%  Dynamic analysis and tracing tools\citep{asan, valgrind} 
% therefore have been implemented to 
% detect memory errors at runtime, and abort program execution  
% with meaningful error messages when a memory error occur.
% Nevertheless, these tools require instrumentation at compile time and
% slow down program execution by more than 3x, limiting their
% applications during debugging or testing.
% Large language models have been employed to both localize 
% and repair memory bugs in \textit{C} and \textit{C++} programs. 
% TODO

%^C^C Problem formulation (TO BE DETERMINED, NEED LITERATURE REVIEW).
% \paragraph{Problem Formulation} Given a \textit{C,C++} 
% project repository and its bug report consisting of program input,
% and stack trace when program \textbf{crashed}
% \footnote{Including function name and line number}, can we
% utilize coding LLMs or agentic systems to automate bug localization
% and resolution, without any additional information 
% from address sanitizer or similar memory bug detectors?
% We believe this scenario is realistic enough for today's
% mobile-application developers who spend a considerable 
% amount of time reviewing bug reports from end-users
% who unually install a release-version of the buggy
% application, and have no access to the source code or
% debugging tools.

% We summarize our contributions as follows:
% + We provide a Systematic Literature Review of articles related to LLM-based
% automatic program repair since 2021; 
\par 我们归纳我们的贡献如下:
\begin{itemize}
    \item 我们详尽检索了2021年, 有关"基于大语言模型的自动程序修复方法"的文献,
    并提供了系统文献综述 (Systematic Literature Review, SLR);
\end{itemize}
