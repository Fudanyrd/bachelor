%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Keep each line less than 80 characters.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{引\quad 言}

%^C^C Overview of Large Language Models.
% \par Increased computational power, advanced machine-learning model
% \citep{attention}, and access to very large-scale data have led to a
% significant transition to the emergence of \textbf{Large Language Models}
% \citep{overviewllm, llmsurvey}. Trained with expansive and diverse data, pretrained 
% large language models have demonstrated remarkable capability to 
% understand and generate human-like text, making them suitable for 
% various Natural Language Processing (NLP) tasks\citep{nlp}.
% Further Supervised Fine-Tuning (SFT) \citep{sft} equips such models with 
% ability to follow natural language instructions,
% making them powerful tools for a wide range 
% of applications. Large language models, such as ChatGPT \citep{chatgpt},
% LLama \citep{llama}, and Gemini \citep{gemini}, because of their
% rich domain-specific knowledge, have been employed be engineers and
% researchers to automate workflows across various domains.

%^C^C Narrow down;
%^C^C Jump to the point of automated debugging techniques as a whole.
% \par Repairing bugs can be a time-consuming and daunting task
% for even a expert experienced in debugging \citep{incorrectfix}.
% Studies showed that
% debugging activities often accounts for about 50\% of overall 
% development cost of software products \citep{reversibledebug, omnitabledebug}.
% Many factors contribute to the cost of debugging, but the most influential
% ones are the manual efforts required to localize and fix faults 
% \citep{asrsurvey}. Researchers have developed a class of approach,
% namely \textbf{Automated Program Repair}
% \footnote{also known as Automatic Software Repair}, whose key idea is to
% try to automatically localize faults in software systems and produce 
% an actual patch to eliminate them 
% \citep{asrsurvey, asrbib, autobugfixsurvey}.
% Before the era of large language models, automated program repair (APR)
% is implemented by Genetic Programming \citep{genprog}, 
% random search \citep{randomsearch},
% or applying fix patterns/templates \citep{parsystem, tbar}.
% However, empirical studies on automated program repair tools 
% suggest that they struggle to help programmers with bug understanding
% \citep{autodebughelpful, debugbench, expectationonfl}, 
% (some) depends on manually crafted templates,
% and tend to overfit the test suite\citep{overfitinapr, invalidator}
% (i.e. the generated patch violates correctness specification or 
% maintains erroneous behavior).
% To overcome the difficulties to debug real-world systems and generate 
% plausible patch, large language models have been employed for automated
% patch synthesis \citep{fusellm4apr, autobugfixsurvey}. Thanks to their
% context-awareness, proficient coding skills \citep{csllm, codex},
% and zero/few short learning capabilities \citep{fewshotlearner},
% code language models have driven multiple fault localization 
% and APR tools and  demonstrated high effectiveness in fixing 
%  software defects and vulnerabilities
% \citep{securemind, llm4testfreefl, 2xbettervulrepair} 
% across various APR benchmarks \citep{defects4j, swebench, cvedataset}.
%^C^C Stop here. do not talk about limitations of LLM-driven APR.

%^C^C Narrow down;
%^C^C What about automated repairment of memory bugs?
%^C^C existing works, challenges (why difficult), etc.
%^C^C How does LLM-driven APR tools perform?
% \par\texttt{C} and \texttt{C++} are popular system programming languages 
% which do not check memory accesses during execution, causing
% memory bugs to slip in. Memory bugs, such as stack/heap overflow,
% use-after-free, and double free, are common causes of software vulnerabilities 
% and can lead to severe consequences. Moreover, memory bugs 
% are notoriously hard to localize; for a single memory error may not
% have immediately visible program misbehaviors (e.g. process crash or abort).
%  Dynamic analysis and tracing tools\citep{asan, valgrind} 
% therefore have been implemented to 
% detect memory errors at runtime, and abort program execution  
% with meaningful error messages when a memory error occur.
% Nevertheless, these tools require instrumentation at compile time and
% slow down program execution by more than 3x, limiting their
% applications during debugging or testing.
% Large language models have been employed to repair 
% memory bugs and consequent CVEs in \texttt{C} and \texttt{C++} programs. 
% Through preliminary literature review, we found that existing works
% addressing automated vulnerability repairment, including 
% VulRepair \citep{vulrepair}, VulAdvisor \citep{vuladvisor}, 
% VulMaster \citep{vulmaster},
% and Enhanced automated code vulnerability repair \citep{vulrepairusingllm}
% requires the computation-intense task of fine-tuning the 
% backbone language model. Luo et al. integrated Control Flow Graph
% information into their prompt, enabling code LMs to fix 
% vulnerabilities in real-world code \citep{prompt4vulrepair}.
% These works set the basis of automated program repair 
% \textit{when the root-cause of the bug is known}
% (i.e. the vulnerability type is known, and the vulnerable code is localized).
% To our knowledge, this is the first work to try to automate
% memory access bug localization at a repository
% granularity, which is neglected by previous research on vulnerability repair
% but can potentially free developers from the
% tedious workflow of reviewing bug reports, reproducing memory errors
% and fix bugs.

%^C^C Problem formulation (TO BE DETERMINED, NEED LITERATURE REVIEW).
% \paragraph{Problem Formulation} Given a \texttt{C,C++} 
% project repository and its bug report consisting of program input,
% and stack trace when program \textbf{crashed}
% \footnote{Including function name and line number}, can we
% utilize coding LLMs or agentic systems to automate bug localization
% and resolution, assuming the following experimental constraints?

% \begin{itemize}
%     \item Without any additional information 
%      from address sanitizer or similar memory bug detectors.
%     Because of high runtime overhead of these sanitizers,
%     they are not likely to be included in the release
% 	  version of the buggy application.

%    \item Without finetuning existing models or train 
% 	  new language models, i.e. only prompting 
%     published code LM.
%     This is needed to overcome 
% 	  the high computation cost of existing vnulreability 
%     repairment tools.
% \end{itemize}

% We believe this scenario is realistic enough for today's
% mobile-application developers who spend a considerable 
% amount of time reviewing bug reports from end-users
% who unually install a release-version of the buggy
% application, and have no access to the source code or
% debugging tools.

% We summarize our contributions as follows:
% + We provide a Systematic Literature Review of articles related to LLM-based
% automatic program repair (LLM4APR) since 2021; 
\par 我们归纳我们的贡献如下:
\begin{itemize}
    \item 我们详尽检索了2021年, 有关"基于大语言模型的自动程序修复方法"(LLM4APR)
    的文献,
    并提供了系统文献综述 (Systematic Literature Review, SLR);
\end{itemize}
